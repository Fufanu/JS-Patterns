<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>BinaryTree.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="DataStructure.BinarySearchTree.html">BinarySearchTree</a><ul class='methods'><li data-type='method'><a href="DataStructure.BinarySearchTree.html#add">add</a></li><li data-type='method'><a href="DataStructure.BinarySearchTree.html#contains">contains</a></li></ul></li><li><a href="DataStructure.Graph.html">Graph</a><ul class='methods'><li data-type='method'><a href="DataStructure.Graph.html#addLine">addLine</a></li><li data-type='method'><a href="DataStructure.Graph.html#addNode">addNode</a></li><li data-type='method'><a href="DataStructure.Graph.html#find">find</a></li></ul></li><li><a href="DataStructure.HashTable.html">HashTable</a><ul class='methods'><li data-type='method'><a href="DataStructure.HashTable.html#.hashKey">hashKey</a></li><li data-type='method'><a href="DataStructure.HashTable.html#get">get</a></li><li data-type='method'><a href="DataStructure.HashTable.html#remove">remove</a></li><li data-type='method'><a href="DataStructure.HashTable.html#set">set</a></li></ul></li><li><a href="DataStructure.LinkedList.html">LinkedList</a><ul class='methods'><li data-type='method'><a href="DataStructure.LinkedList.html#add">add</a></li><li data-type='method'><a href="DataStructure.LinkedList.html#get">get</a></li><li data-type='method'><a href="DataStructure.LinkedList.html#remove">remove</a></li></ul></li><li><a href="DataStructure.List.html">List</a><ul class='methods'><li data-type='method'><a href="DataStructure.List.html#get">get</a></li><li data-type='method'><a href="DataStructure.List.html#pop">pop</a></li><li data-type='method'><a href="DataStructure.List.html#push">push</a></li><li data-type='method'><a href="DataStructure.List.html#shift">shift</a></li><li data-type='method'><a href="DataStructure.List.html#unshift">unshift</a></li></ul></li><li><a href="DataStructure.Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="DataStructure.Queue.html#dequeue">dequeue</a></li><li data-type='method'><a href="DataStructure.Queue.html#enqueue">enqueue</a></li><li data-type='method'><a href="DataStructure.Queue.html#peek">peek</a></li></ul></li><li><a href="DataStructure.Stack.html">Stack</a><ul class='methods'><li data-type='method'><a href="DataStructure.Stack.html#peek">peek</a></li><li data-type='method'><a href="DataStructure.Stack.html#pop">pop</a></li><li data-type='method'><a href="DataStructure.Stack.html#push">push</a></li></ul></li><li><a href="DataStructure.Tree.html">Tree</a><ul class='methods'><li data-type='method'><a href="DataStructure.Tree.html#add">add</a></li><li data-type='method'><a href="DataStructure.Tree.html#traverse">traverse</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="DataStructure.html">DataStructure</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">BinaryTree.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Created: 02.09.2016
 * Author: Philip Hermes
 *
 * Copyright: 2016 by Hytera Mobilfunk GmbH, All Rights Reserved.
 *
 * NOTICE:
 * THIS MATERIAL IS CONSIDERED A TRADE SECRET BY HYTERA.
 * UNAUTHORIZED ACCESS, USE, REPRODUCTION OR DISTRIBUTION IS PROHIBITED.
 */
"use strict";

/**
 * @class
 * @memberOf DataStructure
 * @classdesc
 * &lt;p>Organize data and with have the ability to efficiently access, search, insert and delete values while
 * keeping them in a sorted order. Binary search trees are similar to linked lists in the sense that it is only
 * necessary to update the immediately surrounding items when adding or removing a value.&lt;/p>
 * &lt;p>Each node can have two children:&lt;/p>
 * &lt;ul>
 *  &lt;li> Left: Less than parent node's value
 *  &lt;li> Right: Greater than parent node's value
 * &lt;/ul>
 * &lt;p>&lt;b>Note:&lt;/b> All values must be unique in the tree.&lt;p>
 *
 * &lt;p>Example:&lt;br>
 * A sequence of numbers:&lt;br>
 * 1  2  3  4  5  6  7&lt;br>
 * And turning it into a tree starting from the center.&lt;br>
 * &lt;img src="../img/btree1.jpg" />&lt;br>
 * This makes the traversal to find a value very efficient. Say we're trying to find the number 5 in our tree:&lt;br>
 * &lt;img src="../img/btree2.jpg" />&lt;br>
 * Only had to do 3 checks to reach the number 5.&lt;/p>
 */
class BinarySearchTree {

  /**
   * The tree has to start with a single parent, the "root" of the tree.
   * @constructor
   */
  constructor() {
    this.root = null;
  }

  /**
   * In order to test if the value exists in the tree, we first need to search
   * through the tree.
   */

  /**
   * Search through the tree it it contains the value.
   * @param {*} value - Value mathing to node in the tree
   * @returns {boolean}
   */
  contains(value) {
    // Start at the root.
    var current = this.root;

    // Keep running as long as their is another node.
    // If a `left` or `right` node is `null` the loop ends.
    while (current) {

      // Move to the right if the value is greater than the current.
      if (value > current.value) {
        current = current.right;
      // Move to the left if the value is less than the current.
      } else if (value &lt; current.value) {
        current = current.left;
      // Otherwise it must be equal and return true.
      } else {
        return true;
      }
    }
    // Return false, if nothing matched.
    return false;
  }

  /**
   * Add a new item to the tree. Start traversal through current nodes, bouncing between left and right nodes
   * depending on them being less than or greater than the value. Add the value if a node is 'null'.
   * @param value
   */
  add(value) {
    // Setup node.
    var node = {
      value: value,
      left: null,
      right: null
    };

    // Simple add node if there is no root.
    if (this.root === null) {
      this.root = node;
      return;
    }

    // Start at the root.
    var current = this.root;

    // Loop until the item has been added or discovered it already exists in the tree.
    while (true) {

      // Move to the right if the value is greater than the current.
      if (value > current.value) {

        // If `right` does not exist, set it to the node, and stop traversing.
        if (!current.right) {
          current.right = node;
          break;
        }

        // Otherwise move on to the right node.
        current = current.right;

      // Move to the left if the value is less than the current.
      } else if (value &lt; current.value) {

        // If `left` does not exist, set it to the node, and stop traversing.
        if (!current.left) {
          current.left = node;
          break;
        }

        // Otherwise move on to the left node.
        current = current.left;

      // Don't do anything, if the number isn't less than or greater, then it must be the same.
      } else {
        break;
      }
    }
  }
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Sep 08 2016 16:19:54 GMT+0200 (Mitteleurop√§ische Sommerzeit) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
